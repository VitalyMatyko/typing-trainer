import express from 'express';
import mongoose, { Schema } from 'mongoose';
import cors from 'cors';
import bcrypt from 'bcryptjs';
import dotenv from 'dotenv';
import * as process from 'process';
import { v4 as uuidv4 } from 'uuid';
import jwt from 'jsonwebtoken';
import cookieParser from 'cookie-parser'


dotenv.config();
const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());
app.use(express.static('public'));
const PORT = process.env.PORT || 5000;


const corsOptions = {
	origin: process.env.NODE_ENV === 'production'
		? 'https://typing-trainer-client.onrender.com'  // –ü—Ä–æ–¥–∞–∫—à–Ω-URL
		: 'http://localhost:5050',  // URL –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
	credentials: true,
};
app.use(cors(corsOptions));

if (!process.env.MONGO_URI) {
	console.error("‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç URI –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö ‚ùå");
	process.exit(1);
}

mongoose
	.connect(process.env.MONGO_URI)
	.then(() => console.log("‚úÖ ‚úîÔ∏è  –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ MongoDB ‚úîÔ∏è "))
	.catch(err => console.error("üî¥ –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ MongoDB:", err));

const userSchema = new Schema({
	user_id: { type: String, unique: true, default: () => uuidv4() },
	name: { type: String, unique: true },
	email: { type: String, unique: true, required: true },
	password: { type: String, required: true },
	dateRegistration: { type: Date, default: Date.now },
	profile: {
		typingTextLength: { type: Number, required: true },
		dailyGoal: { type: Number, required: true },
		speedGoal: { type: Number, required: true },
		language: { type: String, required: true },
		openedLetters: {
			en: { type: [String], default: [] },
			ru: { type: [String], default: [] }
		},
		date: { type: Date, default: Date.now }
	},
	statistics: {
		typingDailyStatisticsData: { type: Number, required: true },
		speedStatisticsData: { type: [Number], required: true },
		accuracyStatisticsData: { type: [Number], required: true },
		timeTypingStatisticsData: { type: [Number], required: true },
		correctlyPressedLettersStatistic: { type: [[String]], required: true },
		inCorrectlyPressedLettersStatistic: { type: [[String]], required: true }
	},
});

const User = mongoose.model('User', userSchema);

if (!process.env.ACCESS_SECRET || !process.env.REFRESH_SECRET) {
	console.error("‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á –¥–ª—è —Ç–æ–∫–µ–Ω–æ–≤ ‚ùå");
	process.exit(1);
}

// Token verification.
const authMiddleware = (req, res, next) => {
	const token = req.cookies.accessToken;

	if (!token) {
		return res.status(401).json({ message: "–¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω" });
	};

	try {
		const decoded = jwt.verify(token, process.env.ACCESS_SECRET);
		if (!decoded || !decoded.userId) {
			return res.status(401).json({ message: `–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω` })
		};
		req.userId = decoded.userId;
		next();
	} catch (error) {
		console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ç–æ–∫–µ–Ω–∞: ${error.message}`);
		return res.status(401).json({ message: `–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω` });
	};
};

// Token update route.
app.post('/refresh', async (req, res) => {
	const refreshToken = req.cookies.refreshToken;
	if (!refreshToken) return res.status(401).json({ message: `–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è` });

	try {
		const decoded = jwt.verify(refreshToken, process.env.REFRESH_SECRET);

		const user = await User.findOne(decoded.userId);
		if (!user) {
			res.clearCookie("refreshToken", { httpOnly: true, secure: true, sameSite: "Strict" });
			return res.status(401).json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
		};

		const newAccessToken = jwt.sign({ userId: decoded.userId }, process.env.ACCESS_SECRET, { expiresIn: '1m' });

		res.cookie("accessToken", newAccessToken, {
			httpOnly: true,
			secure: process.env.NODE_ENV === 'production',
			sameSite: 'strict',
			maxAge: 1 * 60 * 1000,
		})
			.json({ message: `–¢–æ–∫–µ–Ω –æ–±–Ω–æ–≤–ª—ë–Ω` });

	} catch (error) {
		console.error(`–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω: ${error}`);
		res.clearCookie("refreshToken", { httpOnly: true, secure: true, sameSite: "strict" });

		if (error.name === 'TokenExpiredError') {
			return res.status(401).json({ message: '–û—à–∏–±–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏' });
		};
		if (error.name === 'JsonWebTokenError') {
			return res.status(403).json({ message: '–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–æ–∫–µ–Ω' });
		};
		return res.status(403).json({ message: '–û—à–∏–±–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏' });
	};
});

// User registration
app.post('/SignUp', async (req, res) => {
	try {
		const { userName, userEmail, userPassword } = req.body;

		if (!process.env.ACCESS_SECRET || !process.env.REFRESH_SECRET) {
			console.error(`‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ç–æ–∫–µ–Ω ‚ùå`);
			return res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' })
		};

		const existingUser = await User.findOne({ email: userEmail });

		if (existingUser) {
			console.log(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ. –°—Ç–∞—Ç—É—Å: ${existingUser.status} ‚ùå`);
			return res.status(400).json({ redirect: '/', message: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç" });
		};

		const salt = await bcrypt.genSalt(10);
		const hashedPassword = await bcrypt.hash(userPassword, salt);

		const newUser = new User({
			name: userName,
			email: userEmail,
			password: hashedPassword,
			profile: {
				typingTextLength: 10,
				dailyGoal: 10,
				speedGoal: 200,
				language: 'en',
				openedLetters: { en: ['f'], ru: ['–∞'] },
			},
			statistics: {
				typingDailyStatisticsData: 0,
				speedStatisticsData: [],
				accuracyStatisticsData: [],
				timeTypingStatisticsData: [],
				correctlyPressedLettersStatistic: [],
				inCorrectlyPressedLettersStatistic: [],
			},
		});
		await newUser.save();

		const accessToken = jwt.sign({ userId: newUser.user_id }, process.env.ACCESS_SECRET, { expiresIn: '1m' });
		const refreshToken = jwt.sign({ userId: newUser.user_id }, process.env.REFRESH_SECRET, { expiresIn: '7d' });

		res
			.cookie('accessToken', accessToken, {
				httpOnly: true,
				secure: true,
				sameSite: "strict",
				maxAge: 1 * 60 * 1000
			})
			.cookie('refreshToken', refreshToken, {
				httpOnly: true,
				secure: true,
				sameSite: 'strict',
				maxAge: 7 * 24 * 60 * 60 * 1000,
			})
			.json({ redirect: '/', accessToken });

	} catch (error) {
		console.error(`‚ùå  –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:`, error.message + '‚ùå');
		return res.status(500).json({ message: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
	};
});

// User avtorization
app.post('/SignIn', async (req, res) => {
	const { userLoginName, userLoginPassword } = req.body;

	const user = await User.findOne({ name: userLoginName });
	if (!user) {
		return res.status(400).json({ message: "–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å" });
	};

	const isPasswordValid = await bcrypt.compare(userLoginPassword, user.password);
	if (!isPasswordValid) {
		return res.status(400).json({ redirect: '/', message: "–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å" });
	};

	const accessToken = jwt.sign({ userId: user.user_id }, process.env.ACCESS_SECRET, { expiresIn: "1m" });
	const refreshToken = jwt.sign({ userId: user.user_id }, process.env.REFRESH_SECRET, { expiresIn: "7d" });

	res
		.cookie('accessToken', accessToken, {
			httpOnly: true,
			secure: true,
			sameSite: 'strict',
			maxAge: 1 * 60 * 1000,
		})
		.cookie('refreshToken', refreshToken, {
			httpOnly: true,
			secure: true,
			sameSite: 'strict',
			maxAge: 7 * 24 * 60 * 60 * 1000,
		})
		.json({ redirect: '/', accessToken, message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –≤–æ—à—ë–ª' });
});

// User sign out.
app.post('/SignOut', (req, res) => {
	try {
		res
			.clearCookie('accessToken', {
				httpOnly: true,
				secure: process.env.NODE_ENV === 'production',
				sameSite: 'strict',
			})
			.clearCookie("refreshToken", {
				httpOnly: true,
				secure: process.env.NODE_ENV === 'production',
				sameSite: 'strict'
			});
		return res.status(200).json({ redirect: '/', message: `‚úîÔ∏è –í—ã —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞ ‚úîÔ∏è` });
	} catch (error) {
		console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ: ${error.message} ‚ùå`);
		res.status(500).json({ message: ' –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ' });
	};
});

// We get the user from the database.
app.get('/getUser', authMiddleware, async (req, res) => {
	try {
		const user = await User.findOne({ user_id: req.userId }).select('-password');
		if (!user) return res.status(401).json({ message: `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω` });
		res.json(user);
	} catch (error) {
		console.error(`‚ùå  –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${error} ‚ùå`);
		return res.status(404).json({ message: `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω` });
	};
});

//  We get the  all users from the database.
app.get('/getAllUsers', authMiddleware, async (req, res) => {
	try {
		const users = await User.find().select('-password');
		if (!users) return res.status(401).json({ message: `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω` });
		res.json(users);
	} catch (error) {
		console.error(`‚ùå  –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${error} ‚ùå`);
		return res.status(404).json({ message: `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω` });
	};
});

// Route to update user data 
app.post('/updateUserData', authMiddleware, async (req, res) => {
	const { _id, newHistoryData, newStatisticsData } = req.body;
	try {
		if (!_id || !newHistoryData || !newStatisticsData) {
			return res.status(400).json({ message: '‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è ‚ö†Ô∏è' });
		};
		if (typeof _id !== 'string' || !_id.trim() || typeof newHistoryData !== 'object' || typeof newStatisticsData !== 'object') {
			return res.status(400).json({ message: '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' });
		};

		const updatedUserHistoryData = await User.findOneAndUpdate(
			{ _id },
			{ $set: { profile: newHistoryData, statistics: newStatisticsData } },
			{ new: true });

		if (!updatedUserHistoryData) return res.status(404).json({ message: `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω` });
		res.status(200).json(updatedUserHistoryData);

	} catch (error) {
		console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${error.message}`);
		res.status(500).json({ message: `–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞` });
	};
});

app.get('/', (req, res) => {
	try {
		const isServerAvailable = req.url;

		if (!isServerAvailable) {
			res.status(400).json({ message: '–°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –æ—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è' })
		};

		res.status(200).json({ message: '–°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω', host: req.hostname, url: req.url })
	} catch (error) {
		res.status(500).json({ message: `–°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω`, –æ—à–∏–±–∫–∞: error.message });
	};
});

// üöÄ
app.listen(PORT, () => {
	console.log(`‚úÖ ‚úîÔ∏è  –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ http://localhost:${PORT} ‚úîÔ∏è`)
});






